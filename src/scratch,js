export default class Scratch {
  constructor(canvas, imageSrc, width, height) {
    this.isDrawing = false;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this.lastPoint = null;
    this.ctx = this.canvas.getContext("2d");
    this.image = new Image();
    this.image.crossOrigin = "Anonymous";
    this.image.onload = () => {
      this.ctx.drawImage(this.image, 0, 0, width, height);
    };
    this.image.src = imageSrc;
    this.image.style.height = "100%";
    this.image.style.width = "100%";
    this.appURL = "https://scratch-card-app.herokuapp.com";
    this.scReportSent = localStorage.getItem("scReportSent") === "true";
  }

  async sendReport() {
    console.log('sending sc report');
    let scReportSent = this.scReportSent;
    if(scReportSent) return;
    let shop = Shopify.shop || window.location.hostname;
    let sendReport = await fetch(`${this.appURL}?shop=${shop}`);
    let response = await sendReport.json();
    localStorage.setItem("scReportSent", true);
    console.log("send report", response);
  }

  getFilledInPixels(stride) {
    if (!stride || stride < 1) {
      stride = 1;
    }

    let x = 0;
    let y = 0;
    let width = this.canvas.width;
    let height = this.canvas.height;

    const pixels = this.ctx.getImageData(x, y, width, height);

    const total = pixels.data.length / stride;
    let count = 0;

    for (let i = 0; i < pixels.data.length; i += stride) {
      if (parseInt(pixels.data[i], 10) === 0) {
        count++;
      }
    }

    return Math.round((count / total) * 100);
  }

  getMouse(e, canvas) {
    const { top, left } = canvas.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft =
      window.pageXOffset || document.documentElement.scrollLeft;

    let x = 0;
    let y = 0;

    if (e && e.pageX && e.pageY) {
      x = e.pageX - left - scrollLeft;
      y = e.pageY - top - scrollTop;
    } else if (e && e.touches) {
      x = e.touches[0].clientX - left - scrollLeft;
      y = e.touches[0].clientY - top - scrollTop;
    }

    return { x, y };
  }

  distanceBetween(point1, point2) {
    if (point1 && point2) {
      return Math.sqrt(
        Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)
      );
    }

    return 0;
  }

  angleBetween(point1, point2) {
    if (point1 && point2) {
      return Math.atan2(point2.x - point1.x, point2.y - point1.y);
    }
    return 0;
  }

  handlePercentage(filledInPixels = 0) {
    if (this.isFinished) {
      return;
    }

    let finishPercent = 70;

    if (filledInPixels > finishPercent) {
      this.canvas.style.transition = "1s";
      this.canvas.style.opacity = "0";
      this.canvas.style.zIndex = "0";
      this.isFinished = true;
    }
  }

  handleMouseDown = (e) => {
    this.isDrawing = true;
    this.lastPoint = this.getMouse(e, this.canvas);
  };

  handleMouseMove = (e) => {
    const currentPoint = this.getMouse(e, this.canvas);
    const distance = this.distanceBetween(this.lastPoint, currentPoint);
    const angle = this.angleBetween(this.lastPoint, currentPoint);

    let x, y;

    for (let i = 0; i < distance; i++) {
      x = this.lastPoint ? this.lastPoint.x + Math.sin(angle) * i : 0;
      y = this.lastPoint ? this.lastPoint.y + Math.cos(angle) * i : 0;
      this.ctx.globalCompositeOperation = "destination-out";

      if (this.brushImage && this.props.customBrush) {
        this.ctx.drawImage(
          this.brushImage,
          x,
          y,
          this.props.customBrush.width,
          this.props.customBrush.height
        );
      } else {
        this.ctx.beginPath();
        this.ctx.arc(x, y, 20, 0, 2 * Math.PI, false);
        this.ctx.fill();
      }
    }

    this.lastPoint = currentPoint;
    this.handlePercentage(this.getFilledInPixels(32));
    this.sendReport();
  };

  handleMouseUp = () => {
    this.isDrawing = false;
  };

  render() {
    this.canvas.addEventListener("mousedown", this.handleMouseDown);
    this.canvas.addEventListener("touchstart", this.handleMouseMove);
    this.canvas.addEventListener("mousemove", this.handleMouseMove);
    this.canvas.addEventListener("mouseup", this.handleMouseUp);
    this.canvas.addEventListener("touchmove", this.handleMouseMove);
    this.canvas.addEventListener("touchend", this.handleMouseUp);
  }
}
